## Lynx 线程模型

### 深入了解线程模型



### TRP模型（Thread per Request）

### ED模型 （Event Driver）



### Lynx 线程

Lynx为了提高UI的响应速度，将JS引擎与UI线程分离，各自独立运行，状态发现变化的时候，通过消息机制进行通信。Lynx在设计过程中，将各个子模块及其对应的数据结构做了对应的设计，以确保模块之间的协作最大程度的进行异步通信。

Lynx目前使用了三种线程, 分别是服务于UI层的UI线程，服务于JS层的定义线程和网络层的IO线程。这三种线程全部是事件驱动模型，但是各种实现不一样，后续我会具体分析。

Lynx对于每个线程会实例化一个MessageLoop,

多线程操作在访问共享数据的时候，需要加锁来确保数据的完整性，如果多个线程同时获取同一个锁，那么就会产生竞争。这种锁竞争会带来额外的开销，从而降低线程的响应性。Lynx在设计的时候将线程间的通信视为线程要执行某个操作，这样就能直接调用代表该操作的函数，这样形成了一个基于任务队列的线程运行模式。使用基于任务队列的线程运行模式时要求在对问题进行建模时，要提前知道谁是执行者。也就是说，在对问题进行建模时，需要指派好每一个子问题的执行者。这样我们为子问题设计数据结构时，就规定这些数据结构仅仅会被子问题的执行者访问。这样执行者在解决指派给它的问题时，就不需要进行加锁操作，因为在解决问题过程中需要访问的数据不会同时被其它执行者访问。

Lynx核心类图



工作流程



如何使用

* 创建线程：

  ```
  Thread* thread = new Thread(base::MessageLoop::MESSAGE_LOOP_POSIX, "")
  ```


* 执行任务

  ```
  thread->Looper()->PostTask(base::Bind(Func, object, ...))
  ```

  Task执行目标线程分成自己线程和其他线程，对于这两种情况构建task的形式也不一样。

  * Post到自己线程执行，object可能会在需要执行的时候已经被销毁，因此对于object需要使用WeakPtr进行包装，这样在指定到任务的时候，会由WeakPtr知道执行对象是否被回收

  ```c++
   thread_manager_->RunOnJSThreadDelay(
        base::Bind(&Body::LayoutWithTick, weak_ptr_, tick), tick);
  ```

  ​

  * Post到其他线程执行，object可能会在需要执行的时候已经被销毁，对Post到其他线程的object需要添加引用计数，确保object在执行的时候没有被销毁。Lynx对引用计数方式封装过，可以使用ScopedRefPtr进行处理

* ​











